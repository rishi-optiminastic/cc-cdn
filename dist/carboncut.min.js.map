{"version":3,"file":"carboncut.min.js","sources":["../src/utils/helpers.js","../src/core/config.js","../src/core/state.js","../src/core/session.js","../src/utils/uuid.js","../src/utils/logger.js","../src/transport/api.js","../src/transport/api-worker.js","../src/tracking/event.js","../src/tracking/ping.js","../src/tracking/pageview.js","../src/listeners/browser.js","../src/index.js"],"sourcesContent":["/**\n * Get tracker token from URL parameter\n * @returns {string|null} Tracker token\n */\nexport function getTrackerFromURL() {\n  if (typeof window === 'undefined') return null;\n  const params = new URLSearchParams(window.location.search);\n  return params.get('cc_tracker');\n}\n\n/**\n * Get browser metadata\n * @returns {Object} Browser metadata\n */\nexport function getBrowserMetadata() {\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return {};\n  }\n\n  return {\n    user_agent: navigator.userAgent,\n    screen_resolution: `${window.screen.width}x${window.screen.height}`,\n    viewport_size: `${window.innerWidth}x${window.innerHeight}`,\n    language: navigator.language,\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    referrer: document.referrer || 'direct',\n    page_url: window.location.href,\n    page_title: document.title\n  };\n}\n\n/**\n * Get current page info\n * @returns {Object} Page info\n */\nexport function getPageInfo() {\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return {};\n  }\n\n  return {\n    page_path: window.location.pathname,\n    page_url: window.location.href,\n    page_title: document.title,\n    referrer: document.referrer\n  };\n}\n\n/**\n * Check if code is running in browser\n * @returns {boolean}\n */\nexport function isBrowser() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n","import { getTrackerFromURL } from '../utils/helpers.js';\n\n/**\n * Configuration manager\n */\nexport class Config {\n  constructor() {\n    this.defaults = {\n      trackerToken: null,\n      apiUrl: 'http://127.0.0.1:8000/api/v1/events/',\n      sessionId: null,\n      pingInterval: 15000, // 15 seconds\n      debug: false,\n      autoTrack: true, \n      respectDoNotTrack: true, \n      maxRetries: 3,\n      retryDelay: 1000,\n      domain: null,\n    };\n    \n    this.config = { ...this.defaults };\n  }\n\n  /**\n   * Initialize configuration\n   * @param {Object} options User options\n   * @returns {boolean} Success status\n   */\n  init(options = {}) {\n    this.config = {\n      ...this.defaults,\n      ...options,\n      trackerToken: options.trackerToken || getTrackerFromURL()\n    };\n\n    return this.validate();\n  }\n\n  /**\n   * Validate configuration\n   * @returns {boolean} Is valid\n   */\n  validate() {\n    if (!this.config.trackerToken) {\n      console.error('CarbonCut: No tracker token provided. Add data-token=\"YOUR_TOKEN\" to script tag.');\n      return false;\n    }\n\n    if (!this.config.apiUrl) {\n      console.error('CarbonCut: API URL is required');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get configuration value\n   * @param {string} key Configuration key\n   * @returns {*} Configuration value\n   */\n  get(key) {\n    return this.config[key];\n  }\n\n  /**\n   * Set configuration value\n   * @param {string} key Configuration key\n   * @param {*} value Configuration value\n   */\n  set(key, value) {\n    this.config[key] = value;\n  }\n\n  /**\n   * Get all configuration\n   * @returns {Object} All configuration\n   */\n  getAll() {\n    return { ...this.config };\n  }\n}","/**\n * Global state management\n */\nexport class State {\n  constructor() {\n    this.state = {\n      isInitialized: false,\n      timeSpent: 0,\n      lastPath: null,\n      retryCount: 0\n    };\n  }\n\n  /**\n   * Get state value\n   * @param {string} key State key\n   * @returns {*} State value\n   */\n  get(key) {\n    return this.state[key];\n  }\n\n  /**\n   * Set state value\n   * @param {string} key State key\n   * @param {*} value State value\n   */\n  set(key, value) {\n    this.state[key] = value;\n  }\n\n  /**\n   * Increment time spent\n   * @param {number} seconds Seconds to add\n   */\n  incrementTimeSpent(seconds) {\n    this.state.timeSpent += seconds;\n  }\n\n  /**\n   * Reset state\n   */\n  reset() {\n    this.state = {\n      isInitialized: false,\n      timeSpent: 0,\n      lastPath: null,\n      retryCount: 0\n    };\n  }\n\n  /**\n   * Get all state\n   * @returns {Object} All state\n   */\n  getAll() {\n    return { ...this.state };\n  }\n}","import { generateUUID } from '../utils/uuid.js';\n\n/**\n * Session management\n */\nexport class Session {\n  constructor(config, logger) {\n    this.config = config;\n    this.logger = logger;\n    this.sessionId = null;\n  }\n\n  /**\n   * Start a new session\n   * @returns {string} Session ID\n   */\n  start() {\n    this.sessionId = generateUUID();\n    this.config.set('sessionId', this.sessionId);\n    \n    // Store in window for external access\n    if (typeof window !== 'undefined') {\n      window.__CC_SESSION_ID = this.sessionId;\n      window.__CC_TRACKER_TOKEN = this.config.get('trackerToken');\n    }\n    \n    this.logger.log('Session started:', this.sessionId);\n    return this.sessionId;\n  }\n\n  /**\n   * Get current session ID\n   * @returns {string|null} Session ID\n   */\n  getId() {\n    return this.sessionId;\n  }\n\n  /**\n   * End current session\n   */\n  end() {\n    this.logger.log('Session ended:', this.sessionId);\n    this.sessionId = null;\n    this.config.set('sessionId', null);\n  }\n\n  /**\n   * Check if session is active\n   * @returns {boolean} Is active\n   */\n  isActive() {\n    return this.sessionId !== null;\n  }\n}","/**\n * Generate a UUID v4\n * @returns {string} UUID\n */\nexport function generateUUID() {\n  if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  \n  // Fallback for older browsers\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}","/**\n * Logger utility with debug mode support\n */\nexport class Logger {\n  constructor(debug = false) {\n    this.debug = debug;\n    this.prefix = 'CarbonCut:';\n  }\n\n  setDebug(debug) {\n    this.debug = debug;\n  }\n\n  log(...args) {\n    if (this.debug) {\n      console.log(this.prefix, ...args);\n    }\n  }\n\n  warn(...args) {\n    if (this.debug) {\n      console.warn(this.prefix, ...args);\n    }\n  }\n\n  error(...args) {\n    console.error(this.prefix, ...args);\n  }\n\n  info(...args) {\n    if (this.debug) {\n      console.info(this.prefix, ...args);\n    }\n  }\n}","/**\n * API transport layer\n */\nexport class ApiTransport {\n  constructor(config, logger) {\n    this.config = config;\n    this.logger = logger;\n    this.queue = [];\n    this.isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;\n    \n    if (typeof window !== 'undefined') {\n      this.setupOnlineListener();\n    }\n  }\n\n  /**\n   * Setup online/offline listener\n   */\n  setupOnlineListener() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.logger.log('Connection restored, flushing queue');\n      this.flushQueue();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.logger.warn('Connection lost, events will be queued');\n    });\n  }\n\n  /**\n   * Send event to API\n   * @param {Object} payload Event payload\n   * @returns {Promise<boolean>} Success status\n   */\n  async send(payload) {\n    if (!this.isOnline) {\n      this.logger.warn('Offline, queueing event');\n      this.queue.push(payload);\n      return false;\n    }\n\n    const apiUrl = this.config.get('apiUrl');\n    \n    try {\n      // Try sendBeacon first (for session_end and critical events)\n      if (this.shouldUseSendBeacon(payload.event)) {\n        const success = this.sendViaBeacon(apiUrl, payload);\n        if (success) {\n          this.logger.log('Event sent via sendBeacon:', payload.event);\n          return true;\n        }\n      }\n\n      // Fallback to fetch\n      await this.sendViaFetch(apiUrl, payload);\n      this.logger.log('Event sent via fetch:', payload.event);\n      return true;\n\n    } catch (error) {\n      this.logger.error('Failed to send event:', error);\n      this.queue.push(payload);\n      return false;\n    }\n  }\n\n  /**\n   * Send via sendBeacon\n   * @param {string} url API URL\n   * @param {Object} payload Event payload\n   * @returns {boolean} Success status\n   */\n  sendViaBeacon(url, payload) {\n    if (typeof navigator === 'undefined' || !navigator.sendBeacon) {\n      return false;\n    }\n\n    try {\n      const blob = new Blob([JSON.stringify(payload)], { \n        type: 'application/json' \n      });\n      return navigator.sendBeacon(url, blob);\n    } catch (error) {\n      this.logger.error('sendBeacon failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Send via fetch\n   * @param {string} url API URL\n   * @param {Object} payload Event payload\n   * @returns {Promise<Response>} Fetch response\n   */\n  async sendViaFetch(url, payload) {\n    this.logger.log('Sending via fetch to:', url, payload);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Tracker-Token': this.config.get('trackerToken')\n      },\n      body: JSON.stringify(payload),\n      keepalive: true\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response;\n  }\n\n  /**\n   * Check if event should use sendBeacon\n   * @param {string} eventType Event type\n   * @returns {boolean} Should use sendBeacon\n   */\n  shouldUseSendBeacon(eventType) {\n    return ['session_end', 'page_unload'].includes(eventType);\n  }\n\n  /**\n   * Flush queued events\n   */\n  async flushQueue() {\n    if (this.queue.length === 0) return;\n\n    this.logger.log(`Flushing ${this.queue.length} queued events`);\n    const queue = [...this.queue];\n    this.queue = [];\n\n    for (const payload of queue) {\n      const success = await this.send(payload);\n      if (!success) {\n        // Re-queue if failed\n        this.queue.push(payload);\n      }\n    }\n  }\n\n  /**\n   * Get queue size\n   * @returns {number} Queue size\n   */\n  getQueueSize() {\n    return this.queue.length;\n  }\n}","/**\n * API Transport using Web Worker\n */\nexport class ApiWorkerTransport {\n  constructor(config, logger) {\n    this.config = config;\n    this.logger = logger;\n    this.worker = null;\n    this.isSupported = this.checkWorkerSupport();\n    this.queueSize = 0;\n    \n    if (this.isSupported) {\n      this.initWorker();\n    } else {\n      this.logger.warn('Web Workers not supported, falling back to main thread');\n    }\n  }\n\n  /**\n   * Check if Web Workers are supported\n   */\n  checkWorkerSupport() {\n    return typeof Worker !== 'undefined';\n  }\n\n  /**\n   * Initialize Web Worker\n   */\n  initWorker() {\n    try {\n      // Inline worker using Blob URL\n      const workerCode = this.getWorkerCode();\n      const blob = new Blob([workerCode], { type: 'application/javascript' });\n      const workerUrl = URL.createObjectURL(blob);\n      \n      this.worker = new Worker(workerUrl);\n      \n      // Listen for messages from worker\n      this.worker.addEventListener('message', (event) => {\n        this.handleWorkerMessage(event.data);\n      });\n      \n      // Listen for errors\n      this.worker.addEventListener('error', (error) => {\n        this.logger.error('Worker error:', error);\n      });\n      \n      // Initialize worker with config\n      this.worker.postMessage({\n        type: 'INIT',\n        payload: {\n          apiUrl: this.config.get('apiUrl'),\n          trackerToken: this.config.get('trackerToken'),\n          batchSize: 10,\n          batchInterval: 5000 // Flush every 5 seconds\n        }\n      });\n      \n      // Setup online/offline detection\n      this.setupOnlineListener();\n      \n      this.logger.log('Web Worker initialized for event processing');\n    } catch (error) {\n      this.logger.error('Failed to initialize worker:', error);\n      this.worker = null;\n    }\n  }\n\n  /**\n   * Get worker code as string\n   */\n  getWorkerCode() {\n    // Return the worker code from event-worker.js as string\n    // In production, this would be bundled separately\n    return `\n      let config = null;\n      let eventQueue = [];\n      let flushTimer = null;\n      let isOnline = true;\n\n      self.addEventListener('message', async (event) => {\n        const { type, payload } = event.data;\n\n        switch (type) {\n          case 'INIT':\n            config = payload;\n            if (config.batchInterval) {\n              flushTimer = setInterval(() => {\n                if (eventQueue.length > 0) {\n                  flushQueue();\n                }\n              }, config.batchInterval);\n            }\n            self.postMessage({ type: 'INIT_SUCCESS' });\n            break;\n          \n          case 'TRACK_EVENT':\n            eventQueue.push({ ...payload, queuedAt: Date.now() });\n            if (eventQueue.length >= (config.batchSize || 10)) {\n              flushQueue();\n            }\n            break;\n          \n          case 'FLUSH_QUEUE':\n            await flushQueue();\n            break;\n          \n          case 'ONLINE':\n            isOnline = true;\n            await flushQueue();\n            break;\n          \n          case 'OFFLINE':\n            isOnline = false;\n            break;\n          \n          case 'GET_QUEUE_SIZE':\n            self.postMessage({ type: 'QUEUE_SIZE', size: eventQueue.length });\n            break;\n        }\n      });\n\n      async function flushQueue() {\n        if (eventQueue.length === 0 || !isOnline) return;\n        \n        const batch = [...eventQueue];\n        eventQueue = [];\n        \n        try {\n          const response = await fetch(config.apiUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'X-Tracker-Token': config.trackerToken\n            },\n            body: JSON.stringify({ events: batch, batch: true }),\n            keepalive: true\n          });\n          \n          if (!response.ok) throw new Error(\\`HTTP \\${response.status}\\`);\n          \n          self.postMessage({ type: 'FLUSH_SUCCESS', count: batch.length });\n        } catch (error) {\n          eventQueue.push(...batch);\n          self.postMessage({ type: 'FLUSH_ERROR', error: error.message, count: batch.length });\n        }\n      }\n    `;\n  }\n\n  /**\n   * Handle messages from worker\n   */\n  handleWorkerMessage(data) {\n    const { type, count, error, size } = data;\n    \n    switch (type) {\n      case 'INIT_SUCCESS':\n        this.logger.log('Worker ready');\n        break;\n      \n      case 'FLUSH_SUCCESS':\n        this.logger.log(`Worker flushed ${count} events`);\n        break;\n      \n      case 'FLUSH_ERROR':\n        this.logger.error(`Worker flush failed: ${error}`);\n        break;\n      \n      case 'QUEUE_SIZE':\n        this.queueSize = size;\n        break;\n    }\n  }\n\n  /**\n   * Setup online/offline listener\n   */\n  setupOnlineListener() {\n    window.addEventListener('online', () => {\n      this.worker?.postMessage({ type: 'ONLINE' });\n    });\n\n    window.addEventListener('offline', () => {\n      this.worker?.postMessage({ type: 'OFFLINE' });\n    });\n  }\n\n  /**\n   * Send event (queued in worker)\n   */\n  async send(payload) {\n    if (!this.worker) {\n      // Fallback to direct fetch if worker not available\n      return this.sendDirect(payload);\n    }\n    \n    this.worker.postMessage({\n      type: 'TRACK_EVENT',\n      payload\n    });\n    \n    return true; // Event queued in worker\n  }\n\n  /**\n   * Direct send fallback (no worker)\n   */\n  async sendDirect(payload) {\n    try {\n      const response = await fetch(this.config.get('apiUrl'), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Tracker-Token': this.config.get('trackerToken')\n        },\n        body: JSON.stringify(payload),\n        keepalive: true\n      });\n      \n      return response.ok;\n    } catch (error) {\n      this.logger.error('Direct send failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Flush queue immediately\n   */\n  async flushQueue() {\n    this.worker?.postMessage({ type: 'FLUSH_QUEUE' });\n  }\n\n  /**\n   * Get queue size\n   */\n  getQueueSize() {\n    if (!this.worker) return 0;\n    \n    this.worker.postMessage({ type: 'GET_QUEUE_SIZE' });\n    return this.queueSize;\n  }\n\n  /**\n   * Terminate worker\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.logger.log('Worker terminated');\n    }\n  }\n}","/**\n * Event tracker\n */\nexport class EventTracker {\n  constructor(config, session, transport, logger) {\n    this.config = config;\n    this.session = session;\n    this.transport = transport;\n    this.logger = logger;\n    this.sentEvents = new Map(); // ← ADD: Track sent events to prevent duplicates\n  }\n\n  /**\n   * Send event to transport\n   * @param {string} event Event type\n   * @param {Object} data Event data\n   */\n  send(event, data = {}) {\n    if (!this.session.isActive()) {\n      this.logger.error('Cannot send event without active session');\n      return;\n    }\n\n    const payload = {\n      event,\n      session_id: this.session.getId(),\n      tracker_token: this.config.get('trackerToken'),\n      timestamp: new Date().toISOString(),\n      ...data\n    };\n\n    // Create unique event key to prevent duplicates\n    const eventKey = `${event}_${payload.timestamp}_${JSON.stringify(data)}`;\n    \n    // Check if event was already sent in last 1 second\n    if (this.sentEvents.has(eventKey)) {\n      this.logger.warn('Duplicate event prevented:', event);\n      return;\n    }\n\n    // Mark event as sent\n    this.sentEvents.set(eventKey, Date.now());\n    \n    // Clean up old entries after 2 seconds\n    setTimeout(() => {\n      this.sentEvents.delete(eventKey);\n    }, 2000);\n\n    // Send to transport\n    this.transport.send(payload);\n  }\n\n  /**\n   * Track custom event\n   * @param {string} eventName Custom event name\n   * @param {Object} data Event data\n   */\n  trackCustomEvent(eventName, data = {}) {\n    this.send('custom_event', {\n      event_name: eventName,\n      event_data: data,\n      page_url: typeof window !== 'undefined' ? window.location.href : null\n    });\n    \n    this.logger.log('Custom event tracked:', eventName);\n  }\n}","/**\n * Ping mechanism for time tracking\n */\nexport class PingTracker {\n  constructor(config, state, eventTracker, logger) {\n    this.config = config;\n    this.state = state;\n    this.eventTracker = eventTracker;\n    this.logger = logger;\n    this.timer = null;\n  }\n\n  /**\n   * Start ping timer\n   */\n  start() {\n    this.stop(); // Clear any existing timer\n\n    const interval = this.config.get('pingInterval');\n    \n    this.timer = setInterval(() => {\n      const seconds = interval / 1000;\n      this.state.incrementTimeSpent(seconds);\n      this.ping();\n    }, interval);\n\n    this.logger.log(`Ping timer started. Interval: ${interval / 1000}s`);\n  }\n\n  /**\n   * Stop ping timer\n   */\n  stop() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n      this.logger.log('Ping timer stopped');\n    }\n  }\n\n  /**\n   * Send ping event\n   */\n  ping() {\n    this.eventTracker.send('ping', {\n      time_spent_seconds: this.state.get('timeSpent'),\n      page_url: typeof window !== 'undefined' ? window.location.href : null,\n      is_visible: typeof document !== 'undefined' ? !document.hidden : true\n    });\n  }\n\n  /**\n   * Manually trigger ping\n   */\n  trigger() {\n    this.ping();\n  }\n\n  /**\n   * Check if timer is running\n   * @returns {boolean} Is running\n   */\n  isRunning() {\n    return this.timer !== null;\n  }\n}","import { getPageInfo } from '../utils/helpers.js';\n\n/**\n * Page view tracking\n */\nexport class PageViewTracker {\n  constructor(config, state, eventTracker, logger) {\n    this.config = config;\n    this.state = state;\n    this.eventTracker = eventTracker;\n    this.logger = logger;\n  }\n\n  /**\n   * Track page view\n   * @param {string} pagePath Page path (optional)\n   */\n  track(pagePath) {\n    const pageInfo = getPageInfo();\n    \n    if (pagePath) {\n      pageInfo.page_path = pagePath;\n    }\n\n    this.eventTracker.send('page_view', pageInfo);\n    this.state.set('lastPath', pageInfo.page_path);\n    this.logger.log('Page view tracked:', pageInfo.page_path);\n  }\n}","\n/**\n * Browser event listeners\n */\nexport class BrowserListeners {\n  constructor(config, state, session, eventTracker, pingTracker, pageViewTracker, logger) {\n    this.config = config;\n    this.state = state;\n    this.session = session;\n    this.eventTracker = eventTracker;\n    this.pingTracker = pingTracker;\n    this.pageViewTracker = pageViewTracker;\n    this.logger = logger;\n  }\n\n  /**\n   * Setup all browser event listeners\n   */\n  setup() {\n    if (typeof window === 'undefined') return;\n\n    this.setupUnloadListener();\n    this.setupVisibilityListener();\n    \n    if (this.config.get('autoTrack')) {\n      this.setupNavigationListeners();\n    }\n  }\n\n  /**\n   * Setup beforeunload listener\n   */\n  setupUnloadListener() {\n    window.addEventListener('beforeunload', () => {\n      this.pingTracker.stop();\n      this.eventTracker.send('session_end', {\n        total_time_spent_seconds: this.state.get('timeSpent'),\n        page_url: window.location.href\n      });\n      this.session.end();\n    });\n  }\n\n  /**\n   * Setup visibility change listener\n   */\n  setupVisibilityListener() {\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.pingTracker.stop();\n        this.logger.log('Page hidden, ping timer paused');\n      } else {\n        this.pingTracker.start();\n        this.logger.log('Page visible, ping timer resumed');\n      }\n    });\n  }\n\n  /**\n   * Setup navigation listeners for SPAs\n   */\n  setupNavigationListeners() {\n    this.state.set('lastPath', window.location.pathname);\n\n    const checkPathChange = () => {\n      const currentPath = window.location.pathname;\n      const lastPath = this.state.get('lastPath');\n      \n      if (currentPath !== lastPath) {\n        this.pageViewTracker.track(currentPath);\n      }\n    };\n\n    // Listen for history changes\n    window.addEventListener('popstate', checkPathChange);\n\n    // Intercept pushState and replaceState\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = function() {\n      originalPushState.apply(this, arguments);\n      checkPathChange();\n    };\n\n    history.replaceState = function() {\n      originalReplaceState.apply(this, arguments);\n      checkPathChange();\n    };\n\n    this.logger.log('SPA navigation tracking enabled');\n  }\n}","import { Config } from './core/config.js';\nimport { State } from './core/state.js';\nimport { Session } from './core/session.js';\nimport { Logger } from './utils/logger.js';\nimport { ApiTransport } from './transport/api.js';\nimport { ApiWorkerTransport } from './transport/api-worker.js';\nimport { EventTracker } from './tracking/event.js';\nimport { PingTracker } from './tracking/ping.js';\nimport { PageViewTracker } from './tracking/pageview.js';\nimport { BrowserListeners } from './listeners/browser.js';\nimport { getBrowserMetadata, isBrowser } from './utils/helpers.js';\n\n/**\n * CarbonCut SDK Main Class\n */\nclass CarbonCutSDK {\n  constructor() {\n    this.logger = new Logger(false);\n    this.config = new Config();\n    this.state = new State();\n    this.session = null;\n    this.transport = null;\n    this.eventTracker = null;\n    this.pingTracker = null;\n    this.pageViewTracker = null;\n    this.browserListeners = null;\n    this.googleAds = null;\n    this.autoInitAttempted = false;\n  }\n\n  /**\n   * Extract tracker token and domain from script tag\n   * @returns {Object} Configuration from script tag\n   */\n  getScriptConfig() {\n    // if (typeof document === 'undefined') return null;\n\n    const scripts = document.getElementsByTagName('script');\n    let scriptConfig = null;\n\n    for (let script of scripts) {\n      const src = script.getAttribute('src');\n      \n      if (src && (src.includes('carboncut.min.js') || src.includes('carboncut.js'))) {\n        scriptConfig = {\n          trackerToken: script.getAttribute('data-token') || script.getAttribute('data-tracker-token'),\n          apiUrl: script.getAttribute('data-api-url') || 'http://127.0.0.1:8000/api/v1/events/',\n          debug: script.getAttribute('data-debug') === 'true',\n          domain: script.getAttribute('data-domain') || window.location.hostname,\n          useWorker: script.getAttribute('data-use-worker') !== 'false' // Default true\n        };\n        break;\n      }\n    }\n\n    return scriptConfig;\n  }\n\n  /**\n   * Auto-initialize from script tag attributes\n   */\n  autoInit() {\n    // Prevent multiple auto-init calls\n    if (this.autoInitAttempted || this.isInitializing) {\n      this.logger.warn('Auto-init already attempted or in progress');\n      return;\n    }\n    \n    this.autoInitAttempted = true;\n    this.isInitializing = true;\n\n    const scriptConfig = this.getScriptConfig();\n    \n    if (!scriptConfig || !scriptConfig.trackerToken) {\n      console.error('CarbonCut: No tracker token found. Add data-token attribute to script tag.');\n      this.isInitializing = false;\n      return;\n    }\n\n    this.init(scriptConfig);\n    this.isInitializing = false;\n  }\n\n  /**\n   * Initialize the SDK\n   */\n  init(options = {}) {\n    if (!isBrowser()) {\n      this.logger.error('CarbonCut SDK can only be initialized in a browser environment');\n      return false;\n    }\n\n    if (this.state.get('isInitialized')) {\n      this.logger.warn('CarbonCut is already initialized');\n      return false;\n    }\n\n    // Initialize configuration\n    if (!this.config.init(options)) {\n      return false;\n    }\n\n    // Set debug mode\n    this.logger.setDebug(this.config.get('debug'));\n\n    // Check Do Not Track\n    if (this.config.get('respectDoNotTrack') && navigator.doNotTrack === '1') {\n      this.logger.warn('Do Not Track is enabled, tracking disabled');\n      return false;\n    }\n\n    // Initialize components\n    this.session = new Session(this.config, this.logger);\n    \n    // Use Worker Transport if supported, fallback to regular transport\n    const useWorker = this.config.get('useWorker') !== false; // Default true\n    \n    if (useWorker && typeof Worker !== 'undefined') {\n      this.transport = new ApiWorkerTransport(this.config, this.logger);\n      this.logger.log('Using Web Worker for event processing');\n    } else {\n      this.transport = new ApiTransport(this.config, this.logger);\n      this.logger.log('Using main thread for event processing');\n    }\n    \n    this.eventTracker = new EventTracker(this.config, this.session, this.transport, this.logger);\n    this.pingTracker = new PingTracker(this.config, this.state, this.eventTracker, this.logger);\n    this.pageViewTracker = new PageViewTracker(this.config, this.state, this.eventTracker, this.logger);\n    this.browserListeners = new BrowserListeners(\n      this.config,\n      this.state,\n      this.session,\n      this.eventTracker,\n      this.pingTracker,\n      this.pageViewTracker,\n      this.logger\n    );\n\n\n    // Start session\n    this.session.start();\n\n    // Send session start event\n    this.eventTracker.send('session_start', getBrowserMetadata());\n\n    // Start ping timer\n    this.pingTracker.start();\n\n    // Setup event listeners\n    this.browserListeners.setup();\n\n    // Mark as initialized\n    this.state.set('isInitialized', true);\n\n    this.logger.log('CarbonCut SDK initialized successfully', {\n      sessionId: this.session.getId(),\n      trackerToken: this.config.get('trackerToken'),\n      workerEnabled: useWorker\n    });\n\n    // Auto-trigger Google Ads OAuth if enabled\n    if (this.config.get('autoAuth')) {\n      // Run OAuth in next tick to not block initialization\n      setTimeout(() => {\n        this.initiateGoogleAdsAuth();\n      }, 0);\n    }\n\n    return true;\n  }\n\n  /**\n   * Track a custom event\n   * @param {string} eventName Event name\n   * @param {Object} data Event data\n   */\n  trackEvent(eventName, data = {}) {\n    if (!this.state.get('isInitialized')) {\n      this.logger.error('SDK not initialized. Call init() first');\n      return;\n    }\n\n    this.eventTracker.trackCustomEvent(eventName, data);\n  }\n\n  /**\n   * Track a page view\n   * @param {string} pagePath Page path\n   */\n  trackPageView(pagePath) {\n    if (!this.state.get('isInitialized')) {\n      this.logger.error('SDK not initialized. Call init() first');\n      return;\n    }\n\n    this.pageViewTracker.track(pagePath);\n  }\n\n  /**\n   * Manually trigger a ping\n   */\n  ping() {\n    if (!this.state.get('isInitialized')) {\n      this.logger.error('SDK not initialized. Call init() first');\n      return;\n    }\n\n    this.pingTracker.trigger();\n  }\n\n  /**\n   * Get session information\n   * @returns {Object} Session info\n   */\n  getSessionInfo() {\n    return {\n      sessionId: this.session?.getId() || null,\n      trackerToken: this.config.get('trackerToken'),\n      timeSpent: this.state.get('timeSpent'),\n      isInitialized: this.state.get('isInitialized'),\n      queueSize: this.transport?.getQueueSize() || 0\n    };\n  }\n\n  /**\n   * Enable debug mode\n   */\n  enableDebug() {\n    this.logger.setDebug(true);\n    this.config.set('debug', true);\n  }\n\n  /**\n   * Disable debug mode\n   */\n  disableDebug() {\n    this.logger.setDebug(false);\n    this.config.set('debug', false);\n  }\n\n  /**\n   * Cleanup and terminate\n   */\n  destroy() {\n    this.pingTracker?.stop();\n    this.transport?.terminate?.(); // Terminate worker if exists\n    this.session?.end();\n    this.state.reset();\n    this.logger.log('SDK destroyed');\n  }\n}\n\n// Create singleton instance\nconst carbonCut = new CarbonCutSDK();\n\n// Auto-initialize when DOM is ready (ONLY ONCE)\nif (typeof document !== 'undefined') {\n  // Only attach listener if document is still loading\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      carbonCut.autoInit();\n    }, { once: true }); // ← ADD 'once: true' to ensure single execution\n  } else {\n    // DOM already loaded, init immediately\n    carbonCut.autoInit();\n  }\n}\n\n// Export for different module systems\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = carbonCut;\n}\n\nif (typeof window !== 'undefined') {\n  window.CarbonCut = carbonCut;\n}\n\nexport default carbonCut;"],"names":["getTrackerFromURL","window","URLSearchParams","location","search","get","Config","constructor","this","defaults","trackerToken","apiUrl","sessionId","pingInterval","debug","autoTrack","respectDoNotTrack","maxRetries","retryDelay","domain","config","init","options","validate","console","error","key","set","value","getAll","State","state","isInitialized","timeSpent","lastPath","retryCount","incrementTimeSpent","seconds","reset","Session","logger","start","crypto","randomUUID","replace","c","r","Math","random","toString","__CC_SESSION_ID","__CC_TRACKER_TOKEN","log","getId","end","isActive","Logger","prefix","setDebug","args","warn","info","ApiTransport","queue","isOnline","navigator","onLine","setupOnlineListener","addEventListener","flushQueue","send","payload","push","shouldUseSendBeacon","event","sendViaBeacon","sendViaFetch","url","sendBeacon","blob","Blob","JSON","stringify","type","response","fetch","method","headers","body","keepalive","ok","Error","status","eventType","includes","length","getQueueSize","ApiWorkerTransport","worker","isSupported","checkWorkerSupport","queueSize","initWorker","Worker","workerCode","getWorkerCode","workerUrl","URL","createObjectURL","handleWorkerMessage","data","postMessage","batchSize","batchInterval","count","size","sendDirect","terminate","EventTracker","session","transport","sentEvents","Map","session_id","tracker_token","timestamp","Date","toISOString","eventKey","has","now","setTimeout","delete","trackCustomEvent","eventName","event_name","event_data","page_url","href","PingTracker","eventTracker","timer","stop","interval","setInterval","ping","clearInterval","time_spent_seconds","is_visible","document","hidden","trigger","isRunning","PageViewTracker","track","pagePath","pageInfo","page_path","pathname","page_title","title","referrer","BrowserListeners","pingTracker","pageViewTracker","setup","setupUnloadListener","setupVisibilityListener","setupNavigationListeners","total_time_spent_seconds","checkPathChange","currentPath","originalPushState","history","pushState","originalReplaceState","replaceState","apply","arguments","carbonCut","browserListeners","googleAds","autoInitAttempted","getScriptConfig","scripts","getElementsByTagName","scriptConfig","script","src","getAttribute","hostname","useWorker","autoInit","isInitializing","doNotTrack","user_agent","userAgent","screen_resolution","screen","width","height","viewport_size","innerWidth","innerHeight","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","workerEnabled","initiateGoogleAdsAuth","trackEvent","trackPageView","getSessionInfo","enableDebug","disableDebug","destroy","readyState","once","module","exports","CarbonCut"],"mappings":"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"}